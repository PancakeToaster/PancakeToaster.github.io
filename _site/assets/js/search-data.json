{"0": {
    "doc": "Home",
    "title": "üìã Robot Control Project Documentation",
    "content": "This project contains a professional-grade control system for a VEX V5 robot, featuring high-precision Odometry, PID control, and Boomerang pathfinding. ",
    "url": "/README.html#-robot-control-project-documentation",
    
    "relUrl": "/README.html#-robot-control-project-documentation"
  },"1": {
    "doc": "Home",
    "title": "üìö Table of Contents",
    "content": ". | Chapter 1: Autonomous Chassis Movement | Chapter 2: Motor Control Algorithms | Chapter 3: PID Explained | Chapter 4: PID Algorithm Breakdown | Chapter 5: Odometry | Chapter 6: Pure Pursuit and Boomerang | Chapter 7: Pure Pursuit | Chapter 8: Boomerang | Chapter 9: Autonomous Troubleshooting Guide | Chapter 10: Documentation of Programming | . Appendices . | Appendix A: Robot Control Library Documentation | Appendix B: The Robot Coding Glossary | . ",
    "url": "/README.html#-table-of-contents",
    
    "relUrl": "/README.html#-table-of-contents"
  },"2": {
    "doc": "Home",
    "title": "1. pid.cpp: Line-by-Line Logic",
    "content": "This class manages the ‚ÄúCorrection Math‚Äù for the robot. It ensures that when you say ‚ÄúGo 24 inches,‚Äù the robot actually goes exactly 24 inches and stops smoothly. C++ . double PID::update(double input) { // 1. Find the distance to the goal current_error = target - input; // 2. The \"Brake\" (Derivative) // We subtract the previous error from current error to see how fast we are moving. derivative = current_error - prev_error; prev_error = current_error; // 3. The \"Muscle\" (Integral) // If we are within a certain range but not at the target, we start adding up the error. if (fabs(current_error) &gt;= integral_range &amp;&amp; integral_range != 0) { sum_error = 0; // Too far away? Don't use integral yet. } else { sum_error += current_error; // Add current error to a running total. // Safety: Cap the integral so the robot doesn't go crazy. if (fabs(sum_error) * ki &gt; integral_max &amp;&amp; integral_max != 0) { sum_error = sign(sum_error) * integral_max / ki; } } // 4. Resetting Logic // If we cross the target (overshoot), reset the 'muscle' to prevent shaking. if (sign(sum_error) != sign(current_error) || (fabs(current_error) &lt;= small_error_tolerance)) { sum_error = 0; } // 5. Arrival Check // If error is tiny AND speed (derivative) is tiny for a certain amount of time... if (arrive == true &amp;&amp; fabs(current_error) &lt;= small_error_tolerance &amp;&amp; fabs(derivative) &lt;= derivative_tolerance) { if (Brain.timer(msec) - small_check_time &gt;= small_error_duration) { arrived = true; // We have officially arrived! } } else { small_check_time = Brain.timer(msec); // Not there yet, reset the timer. } // 6. Return the motor voltage (P + I + D) return (kp * current_error) + (ki * sum_error) + (kd * derivative); } . ",
    "url": "/README.html#1-pidcpp-line-by-line-logic",
    
    "relUrl": "/README.html#1-pidcpp-line-by-line-logic"
  },"3": {
    "doc": "Home",
    "title": "2. Odometry Explained: trackXYOdomWheel()",
    "content": "Odometry is like a GPS for your robot. It uses sensors to track every tiny move the robot makes on the field. How it works (The Simple Way): . Imagine you are walking on a giant sheet of graph paper. | Vertical Wheel: Tells you how far you moved Forward/Backward. | Horizontal Wheel: Tells you how far you moved Sideways (strafing). | Inertial Sensor: Tells you what Direction you are facing. | . If you know you walked 10 inches at a 45-degree angle, you can use math (Sine and Cosine) to figure out your new X and Y coordinates on the graph paper. Code Breakdown: . | delta_heading: The change in angle since the last check. | delta_vertical_in: How many inches the forward wheel rolled. | x_pos += ...: We take the ‚Äúlocal‚Äù move (relative to the robot) and rotate it to ‚Äúglobal‚Äù coordinates (relative to the field). | . ",
    "url": "/README.html#2-odometry-explained-trackxyodomwheel",
    
    "relUrl": "/README.html#2-odometry-explained-trackxyodomwheel"
  },"4": {
    "doc": "Home",
    "title": "3. The Boomerang Algorithm",
    "content": "The Boomerang is a smart movement that uses a ‚ÄúCarrot Point‚Äù to help the robot arrive at a destination while facing a specific direction. What is a ‚ÄúCarrot Point‚Äù? . Imagine a donkey chasing a carrot on a stick. If you move the stick, the donkey turns to follow it. | The Carrot Point is a fake target placed in front of the actual goal. | By aiming for the carrot instead of the goal, the robot naturally curves into the final position. | . Code Breakdown: . C++ . // 1. Find distance to the real goal double h = hypot(x - x_pos, y - y_pos); // 2. Place the 'Carrot' in front of the goal // 'dlead' is how far away the carrot is. // Higher dlead = wider curve. Lower dlead = sharper turn. double carrot_x = x - h * cos(degToRad(a)) * dlead; double carrot_y = y - h * sin(degToRad(a)) * dlead; // 3. Target Angle // Find the angle from the robot's current spot to the Carrot. double target_angle = radToDeg(atan2(carrot_x - x_pos, carrot_y - y_pos)); // 4. Move! // Linear speed is based on distance to goal (h). // Turning speed is based on angle to carrot (target_angle). double move_output = movePID.update(h); double turn_output = turnPID.update(getAngleError(target_angle)); . ",
    "url": "/README.html#3-the-boomerang-algorithm",
    
    "relUrl": "/README.html#3-the-boomerang-algorithm"
  },"5": {
    "doc": "Home",
    "title": "4. Examples for Your Docs",
    "content": "Example 1: Driving to a Point . C++ . // Move to the middle of the field (0,0) from anywhere! // Final angle: 90 degrees. Lead: 0.5. boomerang(0, 0, 1, 90, 0.5, 3000, true, 12); . Example 2: Setting up a PID for a Lift . C++ . PID liftPID(0.8, 0.1, 0.5); // Tune these for your specific motor liftPID.setTarget(500); // Move lift to 500 units while(!liftPID.targetArrived()){ liftMotor.spin(fwd, liftPID.update(liftMotor.position(deg)), volt); } . Example 3: Resetting Position (Odom) . C++ . // If you start in the corner, tell the robot where it is. x_pos = -60; // 60 inches from center y_pos = -60; correct_angle = 45; // Facing diagonally . ",
    "url": "/README.html#4-examples-for-your-docs",
    
    "relUrl": "/README.html#4-examples-for-your-docs"
  },"6": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/README.html",
    
    "relUrl": "/README.html"
  },"7": {
    "doc": "Appendix A: Robot Control Library Documentation",
    "title": "1. pid.cpp (The PID Controller Class)",
    "content": "The PID class provides a feedback loop mechanism that calculates the precise power needed to reach a target while minimizing overshoot. PID(double kp, double ki, double kd) . Description: The constructor that initializes the Proportional ($K_p$), Integral ($K_i$), and Derivative ($K_d$) constants. It also sets up default tolerances and internal timers. | Example 1: Initializing a Drive PID . C++ . PID drivePID(1.5, 0.01, 10.0); // Balanced for straight movement . | Example 2: Initializing a Sharp Turn PID . C++ . PID turnPID(3.0, 0, 15.0); // High D-gain to prevent overshooting during spins . | Example 3: Low-Power Precision PID . C++ . PID slowPID(0.5, 0.005, 2.0); // For very slow, careful movements . | . update(double input) . Description: The core math engine. It takes the current sensor value (input), compares it to the target, and returns a voltage output. | Example 1: Basic Loop Usage . C++ . double power = myPID.update(InertialSensor.heading()); . | Example 2: Maintaining Distance . C++ . // Using ultrasonic sensor to stay 10 inches from a wall double output = wallPID.update(DistanceSensor.objectDistance(inches)); . | Example 3: Arm Height Control . C++ . // Calculating power to hold a lift at a specific potentiometer value double liftVoltage = liftPID.update(liftPot.angle(degrees)); . | . targetArrived() . Description: Checks if the robot has reached its destination and stayed there within the ‚Äútolerance‚Äù range for a set amount of time. | Example 1: Blocking Autonomous Movement . C++ . while(!movePID.targetArrived()) { driveChassis(movePID.update(getPos()), movePID.update(getPos())); wait(10, msec); } . | Example 2: Sequencing Actions . C++ . if(turnPID.targetArrived()) { claw.open(); // Only open claw once the turn is fully finished } . | Example 3: Debugging . C++ . if(movePID.targetArrived()) { Brain.Screen.print(\"Robot has settled at target.\"); } . | . setSmallBigErrorTolerance(double small, double big) . Description: Defines two tiers of error ranges. The robot is ‚Äúarrived‚Äù if it stays within these bounds for the required time. | Example 1: High Precision Mode . C++ . pid.setSmallBigErrorTolerance(0.1, 0.5); // Very strict for scoring . | Example 2: Fast Movement Mode . C++ . pid.setSmallBigErrorTolerance(2.0, 5.0); // Loose for traveling across field . | Example 3: Standard Default . C++ . pid.setSmallBigErrorTolerance(1.0, 3.0); // General purpose . | . ",
    "url": "/appendix-A-Robot-Control-Library-Documentation.html#1-pidcpp-the-pid-controller-class",
    
    "relUrl": "/appendix-A-Robot-Control-Library-Documentation.html#1-pidcpp-the-pid-controller-class"
  },"8": {
    "doc": "Appendix A: Robot Control Library Documentation",
    "title": "2. motor-control.cpp (Chassis &amp; Movement)",
    "content": "This file handles the logic for driving the robot and performing complex maneuvers. driveChassis(double left, double right) . Description: Directly sets the voltage (typically -12.0 to 12.0) for the left and right motor groups. | Example 1: Full Speed Forward . C++ . driveChassis(12.0, 12.0); . | Example 2: Pivot Turn Right . C++ . driveChassis(6.0, -6.0); . | Example 3: Gentle Creep . C++ . driveChassis(2.0, 2.0); . | . turnToAngle(double angle, double time_limit, bool exit, double max_output) . Description: Rotates the robot in place to a specific compass heading using the Inertial Sensor. | Example 1: Basic 90-Degree Turn . C++ . turnToAngle(90, 1000, true, 12); // Turn to 90deg, 1s limit, full power . | Example 2: Slow, Precise 180 . C++ . turnToAngle(180, 2000, true, 6); // Max 6 volts for a more controlled turn . | Example 3: Chained Turn (No Stop) . C++ . turnToAngle(45, 800, false, 12); // Don't brake motors after finishing . | . driveTo(double distance_in, double time_limit, bool exit, double max_output) . Description: Drives in a straight line for a specific number of inches. | Example 1: Drive 2 Tiles . C++ . driveTo(48.0, 3000, true, 11); // Drive 48 inches forward . | Example 2: Reverse Movement . C++ . driveTo(-24.0, 1500, true, 12); // Drive 24 inches backward . | Example 3: Short Nudge . C++ . driveTo(5.0, 500, true, 5); // Short, slow nudge to push an object . | . boomerang(double x, double y, int dir, double a, double dlead, ...) . Description: Advanced pathing that moves the robot to an (X, Y) coordinate and ensures it is facing angle a upon arrival. | Example 1: Corner Goal Arc . C++ . // Drive to (24, 24), face 90 degrees, 0.5 lead factor boomerang(24, 24, 1, 90, 0.5, 3000, true, 12); . | Example 2: Reverse Curve . C++ . // Curve backward to (-12, 12) and face 0 degrees boomerang(-12, 12, -1, 0, 0.3, 2000, true, 10); . | Example 3: Tight ‚ÄúS‚Äù Curve . C++ . // Navigate a tight curve with a low dlead factor boomerang(48, 0, 1, 0, 0.2, 4000, true, 12); . | . trackXYOdomWheel() . Description: A background task function that calculates the robot‚Äôs global position using encoder tracking wheels. | Example 1: Starting the Task . C++ . vex::task odomTask(trackXYOdomWheel); // Run tracking in the background . | Example 2: Conditional Trigger . C++ . if(x_pos &gt; 100.0) { intake.stop(); } // Stop intake if robot crosses field line . | Example 3: Position Reset . C++ . if(reset_button.pressing()) { x_pos = 0; y_pos = 0; } // Manual recalibration . | . scaleToMax(double&amp; left, double&amp; right, double max_output) . Description: Adjusts motor powers proportionally so that if one side is commanded over the limit, the turn ratio stays the same. | Example 1: Capping Speed for Curves . C++ . scaleToMax(l_volt, r_volt, 10.0); // Ensure neither side exceeds 10V . | Example 2: Battery Conservation . C++ . scaleToMax(l, r, 8.0); // Limit draw during long movements . | Example 3: Correcting Saturation . C++ . // If l=15 and r=10, scaleToMax(12) makes l=12 and r=8 scaleToMax(left_calc, right_calc, 12.0); . | . ",
    "url": "/appendix-A-Robot-Control-Library-Documentation.html#2-motor-controlcpp-chassis--movement",
    
    "relUrl": "/appendix-A-Robot-Control-Library-Documentation.html#2-motor-controlcpp-chassis--movement"
  },"9": {
    "doc": "Appendix A: Robot Control Library Documentation",
    "title": "Appendix A: Robot Control Library Documentation",
    "content": " ",
    "url": "/appendix-A-Robot-Control-Library-Documentation.html",
    
    "relUrl": "/appendix-A-Robot-Control-Library-Documentation.html"
  },"10": {
    "doc": "Appendix B: The Robot Coding Glossary",
    "title": "Appendix B: The Robot Coding Glossary",
    "content": "General Concepts . | Autonomous: The period of a match where the robot moves by itself using code, with no help from a human driver. | Chassis: The ‚Äúbase‚Äù or ‚Äúframe‚Äù of the robot, including the wheels and the motors that make it move. | Coefficient: A fancy math word for a ‚Äúmultiplier.‚Äù In PID, $K_p$, $K_i$, and $K_d$ are coefficients that change how much power we give the motors. | Constants: Numbers in your code that don‚Äôt change while the program is running (like your PID gains). | . PID Terms . | Error: The distance between where the robot is and where it wants to be. If the goal is 24 inches and you are at 20, the error is 4. | Settling: The moment at the end of a move when the robot stops wobbling and sits perfectly still at the target. | Tolerance: The ‚Äúclose enough‚Äù range. If your tolerance is 0.5 inches, the robot will consider itself ‚Äúarrived‚Äù even if it‚Äôs 0.4 inches away. | Oscillation: When a robot bounces back and forth over a target like a spring. Usually caused by a $K_p$ that is too high. | Integral Windup: When the ‚Äúimpatient‚Äù part of PID ($K_i$) builds up too much power while the robot is stuck, causing it to launch forward dangerously once it breaks free. | . Odometry &amp; Pathing Terms . | Odometry (Odom): The system that tracks the robot‚Äôs $(X, Y)$ position on the field. | Heading: The direction the robot is facing (usually measured from 0 to 360 degrees). | Radians: A different way to measure circles. Instead of 360 degrees, a full circle is $2\\pi$ (about 6.28) radians. Computers love radians for trigonometry. | Delta ($\\Delta$): A Greek letter used in math to mean ‚ÄúThe Change.‚Äù For example, Delta X is how much your X-position changed since the last loop. | Carrot Point: A temporary ‚Äúfake‚Äù target used in Boomerang to pull the robot into a smooth curve. | Lead Factor (dlead): A setting that decides how far away the ‚ÄúCarrot‚Äù is. It determines if your turn is a wide circle or a sharp hook. | . The ‚ÄúMathy‚Äù Functions . | Atan2: A special math function that takes $(X, Y)$ coordinates and tells you exactly what angle you need to turn to face that point. | Hypot (Hypotenuse): A function that calculates the straight-line distance between two points (using the $a^2 + b^2 = c^2$ rule). | Slew Rate: A ‚Äúspeed limit‚Äù for how fast your motor power can change. It prevents the robot from jerking so hard that the wheels slip or the robot tips over. | . Final Project Tip for the Team . When you are explaining your code to judges at a competition, use these words! Instead of saying ‚ÄúWe made the robot stay still,‚Äù say ‚ÄúWe tuned our PID coefficients to minimize oscillation and ensure the robot settled within our small error tolerance.‚Äù It makes a huge difference! . ",
    "url": "/appendix-B-The-Robot-Coding-Glossary.html",
    
    "relUrl": "/appendix-B-The-Robot-Coding-Glossary.html"
  },"11": {
    "doc": "Chapter 1: Autonomous Chassis Movement",
    "title": "Chapter 1: Autonomous Chassis Movement",
    "content": "1. The Logic Flow . The code follows a very simple ‚ÄúIf/Else‚Äù pattern. Imagine you want your robot to drive to a distance of 24 inches using your Odometry or Inertial Sensor for tracking. The Logic Step-by-Step: . | Read Sensor: The robot checks its current position (e.g., ‚ÄúI am at 10 inches‚Äù). | Calculate Error: It subtracts its position from the target ($24 - 10 = 14$ inches of error). | The Decision: . | IF the error is greater than zero (I‚Äôm not there yet), set motors to 100%. | ELSE (I‚Äôve hit or passed the target), set motors to 0%. | . | . 2. What the Code Actually Looks Like (Pseudocode) . Even if you aren‚Äôt a pro-coder yet, the ‚Äúskeleton‚Äù of the code looks like this: . C++ . while (true) { // The robot checks this 50 times every second double currentPosition = LeftEncoder.position(inches); double target = 24.0; if (currentPosition &lt; target) { // BANG! Full power forward LeftMotor.spin(forward, 100, percent); RightMotor.spin(forward, 100, percent); } else { // STOP! LeftMotor.stop(brake); RightMotor.stop(brake); break; // Exit the loop because we arrived } } . 3. Why it‚Äôs called ‚ÄúBang-Bang‚Äù . It gets its name from the sound and feel of the robot. | It starts with a ‚ÄúBANG‚Äù (instant 100% torque), which often makes the robot‚Äôs front wheels lift up slightly. | It ends with a ‚ÄúBANG‚Äù (the mechanical jolt of the robot trying to stop a 15lb frame instantly). | . 4. The ‚ÄúPhysics‚Äù Problem: Momentum . As a first-time roboticist, you will notice something frustrating: The robot will never stop exactly at 24 inches. Because the code only tells the motor to stop after it reaches 24, the robot‚Äôs momentum acts like a heavy bowling ball. It will ‚Äúcoast‚Äù or slide on the foam tiles. By the time it actually stops moving, it might be at 27 inches. 5. How to make it ‚ÄúPro‚Äù (The Middle Step) . Before you jump all the way to a complex PID, you can add one simple line of logic to your Bang-Bang code to make it much better. This is called a Threshold or Slow-Zone. The Improved Logic: . | If distance is $&gt; 5$ inches from target $\\rightarrow$ 100% Power. | If distance is $&lt; 5$ inches from target $\\rightarrow$ 20% Power. | If target is reached $\\rightarrow$ Stop. | . This ‚Äústaged‚Äù Bang-Bang approach reduces the momentum, so your robot doesn‚Äôt slide nearly as far. ",
    "url": "/chapter-01-Autonomous-Chassis-Movement.html",
    
    "relUrl": "/chapter-01-Autonomous-Chassis-Movement.html"
  },"12": {
    "doc": "Chapter 2: Motor Control Algorithms",
    "title": "Chapter 2: Motor Control Algorithms",
    "content": "1. Bang-Bang (On/Off) . Complexity: ‚≠ê This is the simplest form of control. It‚Äôs either 100% power or 0% power. | How it works: If your robot is behind the target, go full speed. If it‚Äôs past the target, stop. | The Problem: It‚Äôs very jerky. Imagine driving a car by only slamming the gas or slamming the brakes‚Äîit‚Äôs bad for your gears and very shaky. | . 2. Slew Rate (Ramping) . Complexity: ‚≠ê‚≠ê This is a small upgrade to manual control that prevents the robot from tipping over. | How it works: It limits how fast the motor power can change. If you push the joystick to 100, the code ‚Äúramps‚Äù the power (20‚Ä¶ 40‚Ä¶ 60‚Ä¶ 80‚Ä¶ 100) instead of jumping instantly. | The Problem: It doesn‚Äôt help with accuracy; it just makes the robot smoother. | . 3. PID Control (The Standard) . Complexity: ‚≠ê‚≠ê‚≠ê This is what most competitive VEX teams use. It uses math to calculate ‚ÄúError‚Äù (how far you are from the target). | P (Proportional): Big move when far away, small move when close. | I (Integral): Fixes the tiny errors that stop the robot just short of the goal. | D (Derivative): The ‚Äúbrake‚Äù that slows the robot down so it doesn‚Äôt overshoot. | The Problem: It can be hard to ‚Äútune‚Äù (finding the right numbers for Kp, Ki, and Kd). | . 4. Feedforward (Prediction) . Complexity: ‚≠ê‚≠ê‚≠ê‚≠ê This is often added to a PID to make it even stronger. | How it works: Instead of waiting for an error to happen, you tell the motor exactly how much power it needs to overcome things like gravity or friction. | Example: If you have a heavy arm, you give the motor a little ‚Äúbase power‚Äù just to hold it up, then let the PID do the actual moving. | . 5. Motion Profiling (Trapezoidal / S-Curve) . Complexity: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê This is how industrial robots move. Instead of just ‚Äúgoing to a point,‚Äù the robot calculates a ‚Äúflight plan.‚Äù . | How it works: You tell the robot its Max Velocity and Max Acceleration. It creates a perfect math curve: it speeds up at a safe rate, cruises at a steady speed, and slows down perfectly. | The Benefit: This is the most consistent way to move. It‚Äôs very easy on the hardware and ensures the robot ends up in the exact same spot every single time. | . ",
    "url": "/chapter-02-Motor-Control-Algorithms.html",
    
    "relUrl": "/chapter-02-Motor-Control-Algorithms.html"
  },"13": {
    "doc": "Chapter 3: PID Explained",
    "title": "üõ†Ô∏è The 3-Step Tuning Guide (The ‚ÄúTrial and Error‚Äù Method)",
    "content": "Before you start, make sure your robot is on a full field with a fresh battery. Set your ki and kd to 0 in your code. Step 1: Find your P (The Gas) . Start with a very small number for kp (like 0.1). | Run the robot. It probably won‚Äôt reach the target. | Keep doubling the number (0.2, 0.4, 0.8‚Ä¶) until the robot reaches the target. | The Goal: You want the robot to move quickly to the target, overshoot it slightly, and ‚Äúbounce‚Äù back and forth maybe 2 or 3 times before stopping. | If it shakes violently: Your kp is too high! . | If it never reaches the goal: Your kp is too low. | . | . Step 2: Find your D (The Brake) . Now that your robot is ‚Äúbouncing‚Äù because of the high kp, we use kd to smooth it out. | Start with a small kd (like 1.0). | Increase it slowly. | The Goal: You want the kd to ‚Äúsoak up‚Äù the bounce. The robot should zoom toward the target and slow down perfectly right at the line without any shaking. | If the robot moves like it‚Äôs driving through molasses: Your kd is too high. | . | . Step 3: Find your I (The Muscle) . Most of the time, you don‚Äôt even need ki. But if your robot stops exactly 0.5 inches away from the goal every time and won‚Äôt move that last bit: . | Set a very tiny ki (like 0.001). | The Goal: The robot should settle near the target, wait half a second, and then ‚Äúnudge‚Äù itself perfectly onto the line. | . üí° Final Pro-Tips for Students . | Fresh Battery: A battery at 100% pushes harder than a battery at 50%. Always tune with a battery around 80-90%. | The ‚ÄúPush‚Äù Test: While your PID is holding the robot at a target, try to push the robot with your hand. A well-tuned PID will fight back and return to the spot immediately. | Keep a Notebook: Write down your numbers! ‚ÄúKp 2.5 was too shaky, Kp 2.1 was perfect.‚Äù You will forget these numbers otherwise. | . ",
    "url": "/chapter-03-PID-Explained.html#%EF%B8%8F-the-3-step-tuning-guide-the-trial-and-error-method",
    
    "relUrl": "/chapter-03-PID-Explained.html#Ô∏è-the-3-step-tuning-guide-the-trial-and-error-method"
  },"14": {
    "doc": "Chapter 3: PID Explained",
    "title": "Chapter 3: PID Explained",
    "content": "To make PID as simple as possible, let‚Äôs stop thinking about math and start thinking about driving a car. Imagine you are sitting in the passenger seat, and your job is to tell the driver how to push the gas pedal to stop exactly at a red light. 1. P is for Proportion (The ‚ÄúLook Ahead‚Äù Rule) . The Concept: The farther away the red light is, the harder you tell the driver to push the gas. As you get closer, you tell them to let off the pedal. | In the code: proportional = kp * current_error; . | Simple Explanation: If you are 100 feet away, you apply a lot of power. If you are only 1 foot away, you apply almost zero power. It‚Äôs a simple ratio. | The Problem: If you only use P, the car might stop a few inches short because there isn‚Äôt enough power to overcome the friction of the tires on the road. | . 2. I is for Integral (The ‚ÄúImpatient‚Äù Rule) . The Concept: Imagine the car has stopped 2 inches short of the line. The driver isn‚Äôt pushing the gas because P is too small. You wait 1 second‚Ä¶ 2 seconds‚Ä¶ 3 seconds‚Ä¶ and you get impatient. You start yelling, ‚ÄúGo! Go! Go!‚Äù until the driver nudges the car that last little bit. | In the code: sum_error += current_error; . | Simple Explanation: This is a timer. It adds up all the time you spent not at the target. The longer you wait, the higher the power grows, forcing the robot to finish the move. | The Problem: If you get too impatient, you might make the driver slam the gas at the last second and overshoot the line. | . 3. D is for Derivative (The ‚ÄúBrake‚Äù Rule) . The Concept: You see the red light coming up fast. You look at the speedometer and realize, ‚ÄúWait, we are going too fast to stop in time!‚Äù You tell the driver to start tapping the brakes before you hit the line. | In the code: derivative = current_error - prev_error; . | Simple Explanation: This looks at your speed. If your error is disappearing very quickly, it means you are moving fast. The D term creates ‚Äúcounter-power‚Äù (braking) to slow you down so you land perfectly. | . How it looks in your code (The Line-by-Line) . C++ . // 1. How far is the goal? current_error = target - input; // 2. How fast are we moving? (The Brake) derivative = current_error - prev_error; // 3. Are we stuck? (The Muscle) // If we are close to the goal, start the \"Impatient Timer\" if (fabs(current_error) &lt; integral_range) { sum_error += current_error; } // 4. Final Math: Power = (Push) + (Yelling) - (Braking) return (kp * current_error) + (ki * sum_error) + (kd * derivative); . Summary Table for Students . | Part | Nickname | What it does | What happens if it‚Äôs too high? | . | P | The Gas | Gets you moving toward the goal. | The robot will shake or bounce like a spring. | . | I | The Muscle | Fixes the ‚Äúalmost there‚Äù gap. | The robot will zoom past the goal or go crazy. | . | D | The Brake | Smooths out the landing. | The robot will move very slowly and feel ‚Äúheavy.‚Äù | . A ‚ÄúGolden Rule‚Äù for Coding It: . When you start testing your robot, always set I and D to zero. Only change P until the robot moves. Once it moves but starts bouncing, add a little D to ‚Äúsoak up‚Äù the bounce. Only add I if the robot is consistently stopping short. ",
    "url": "/chapter-03-PID-Explained.html",
    
    "relUrl": "/chapter-03-PID-Explained.html"
  },"15": {
    "doc": "Chapter 4: PID Algorithm Breakdown",
    "title": "Usage Examples with Code Snippets",
    "content": "Scenario A: Turning using the PID Controller . How to manually use the PID class to rotate your robot. C++ . PID turnPID(2.5, 0, 10); // Create PID with Kp=2.5, Ki=0, Kd=10 turnPID.setTarget(90); // We want to face 90 degrees while(!turnPID.targetArrived()) { double currentHeading = InertialSensor.heading(); double power = turnPID.update(currentHeading); // Apply power: Left motor positive, Right motor negative to spin driveChassis(power, -power); wait(10, msec); } stopChassis(brake); // Stop once arrived . ",
    "url": "/chapter-04-PID-Algorithm-Breakdown.html#usage-examples-with-code-snippets",
    
    "relUrl": "/chapter-04-PID-Algorithm-Breakdown.html#usage-examples-with-code-snippets"
  },"16": {
    "doc": "Chapter 4: PID Algorithm Breakdown",
    "title": "Chapter 4: PID Algorithm Breakdown",
    "content": "The PID (Proportional-Integral-Derivative) controller is the ‚Äúcorrection engine‚Äù that ensures the robot reaches a target smoothly. Parameter Definitions . | Parameter | Description | . | kp (Proportional) | The main ‚Äúpunch.‚Äù Power proportional to how far away the target is. | . | ki (Integral) | The ‚Äúmuscle.‚Äù Increases power over time if the robot is stuck or struggling with friction. | . | kd (Derivative) | The ‚Äúbrake.‚Äù Slows the robot down as it approaches the target to prevent overshooting. | . | small_error_tolerance | How close to the target is ‚Äúgood enough‚Äù for a precise stop. | . | small_error_duration | How many milliseconds the robot must stay in that ‚Äúgood enough‚Äù zone to exit. | . Code Logic Breakdown . Here is the line-by-line logic for the update function: . C++ . double PID::update(double input) { // 1. Calculate the current distance from the goal current_error = target - input; // 2. Calculate Derivative: How fast is the error changing? // (current error - last error) / time. This acts as a brake. derivative = (current_error - prev_error); prev_error = current_error; // 3. Integral Logic: Accumulate error over time to overcome friction. if (fabs(current_error) &gt;= integral_range &amp;&amp; integral_range != 0) { sum_error = 0; // Don't start \"winding up\" the integral until we are close. } else { sum_error += current_error; // Add current error to the running total. // Safety: Prevent Integral Windup (capping the max power the integral can provide) if (fabs(sum_error) * ki &gt; integral_max &amp;&amp; integral_max != 0) { sum_error = sign(sum_error) * integral_max / ki; } } // 4. Stabilization: Clear integral if we overshoot the target or are perfectly centered. if (sign(sum_error) != sign(current_error) || (fabs(current_error) &lt;= small_error_tolerance)) { sum_error = 0; } // 5. Final Calculation: Combine all three terms. proportional = kp * current_error; integral = ki * sum_error; derivative_term = kd * derivative; // Note: In your code this is simplified to kd * derivative // 6. Arrival Check: Are we within tolerance and moving slowly enough (derivative check)? if (arrive == true &amp;&amp; fabs(current_error) &lt;= small_error_tolerance &amp;&amp; fabs(derivative) &lt;= derivative_tolerance) { if (Brain.timer(msec) - small_check_time &gt;= small_error_duration) { arrived = true; // Stayed in the zone long enough! } } else { small_check_time = Brain.timer(msec); // Reset timer if we move out of the zone. } return proportional + integral + derivative_term; // Output voltage to motors. } . ",
    "url": "/chapter-04-PID-Algorithm-Breakdown.html",
    
    "relUrl": "/chapter-04-PID-Algorithm-Breakdown.html"
  },"17": {
    "doc": "Chapter 5: Odometry",
    "title": "1. What is Odometry? (The Simple Version)",
    "content": "Imagine you are in a dark room with a blindfold on. You are standing on a giant piece of grid paper. You know you started at the exact center $(0, 0)$. To figure out where you are after walking around, you need two pieces of information: . | How far did your feet move? (Distance) . | What direction were you pointing? (Heading) . | . If you take 5 steps forward while facing ‚ÄúNorth,‚Äù you know you are now at $(0, 5)$. If you turn right and take 3 steps, you are at $(3, 5)$. Odometry is just a robot using math to do this constantly‚Äîabout 100 times every second‚Äîso it always knows its $(X, Y)$ position on the field. Why do we need ‚ÄúTracking Wheels‚Äù? . Standard drive wheels can slip or ‚Äúburn out‚Äù on the foam tiles. Odometry usually uses small, unpowered Tracking Wheels (with encoders) that touch the ground lightly. Because they aren‚Äôt connected to motors, they don‚Äôt slip, giving the robot a much more accurate ‚Äústep count‚Äù. ",
    "url": "/chapter-05-Odometry.html#1-what-is-odometry-the-simple-version",
    
    "relUrl": "/chapter-05-Odometry.html#1-what-is-odometry-the-simple-version"
  },"18": {
    "doc": "Chapter 5: Odometry",
    "title": "2. trackXYOdomWheel() Line-by-Line Breakdown",
    "content": "This function runs in a background ‚Äútask‚Äù (a loop that never stops) to keep the robot‚Äôs coordinates updated. The Setup . C++ . void trackXYOdomWheel() { resetChassis(); // Clears motor encoders to start at 0 double prev_heading_rad = 0; // Stores the angle from the previous loop double prev_horizontal_pos_deg = 0, prev_vertical_pos_deg = 0; // Stores last wheel positions . The Loop . C++ . while (true) { // 1. Get current sensor readings double heading_rad = degToRad(getInertialHeading()); // Get current angle in radians double horizontal_pos_deg = horizontal_tracker.position(degrees); // Side-to-side wheel double vertical_pos_deg = vertical_tracker.position(degrees); // Forward-backward wheel // 2. Calculate \"Deltas\" (How much did things change since the last 10ms?) double delta_heading_rad = heading_rad - prev_heading_rad; // The turn amount // Convert degrees of wheel rotation into actual inches on the floor double delta_horizontal_in = (horizontal_pos_deg - prev_horizontal_pos_deg) * horizontal_tracker_diameter * M_PI / 360.0; double delta_vertical_in = (vertical_pos_deg - prev_vertical_pos_deg) * vertical_tracker_diameter * M_PI / 360.0; // 3. Local Movement Calculation // If the robot didn't turn, movement is a simple straight line. if (fabs(delta_heading_rad) &lt; 1e-6) { delta_local_x_in = delta_horizontal_in; delta_local_y_in = delta_vertical_in; } else { // If the robot DID turn, it moved in a tiny arc (part of a circle). // This math calculates the \"chord\" (straight line distance) of that arc. double sin_multiplier = 2.0 * sin(delta_heading_rad / 2.0); delta_local_x_in = sin_multiplier * ((delta_horizontal_in / delta_heading_rad) + horizontal_tracker_dist_from_center); delta_local_y_in = sin_multiplier * ((delta_vertical_in / delta_heading_rad) + vertical_tracker_dist_from_center); } // 4. Global Transformation // We know how far we moved relative to the ROBOT (Local). // Now we use Sine and Cosine to figure out how far we moved relative to the FIELD (Global). double polar_radius_in = sqrt(pow(delta_local_x_in, 2) + pow(delta_local_y_in, 2)); // Total distance moved double polar_angle_rad = local_polar_angle_rad - heading_rad - (delta_heading_rad / 2); // The direction x_pos += polar_radius_in * cos(polar_angle_rad); // Update global X y_pos += polar_radius_in * sin(polar_angle_rad); // Update global Y // 5. Store values for the next loop prev_heading_rad = heading_rad; prev_horizontal_pos_deg = horizontal_pos_deg; prev_vertical_pos_deg = vertical_pos_deg; wait(10, msec); // Wait 10 milliseconds and repeat } } . ",
    "url": "/chapter-05-Odometry.html#2-trackxyodomwheel-line-by-line-breakdown",
    
    "relUrl": "/chapter-05-Odometry.html#2-trackxyodomwheel-line-by-line-breakdown"
  },"19": {
    "doc": "Chapter 5: Odometry",
    "title": "3. Parameters Explained",
    "content": "| Variable | Meaning in Middle School Terms | . | horizontal_tracker_diameter | The size of your tracking wheel. Needed to know that 1 full spin = ~8.6 inches. | . | dist_from_center | How far the wheel is from the middle of the robot. If a wheel is off-center, it will spin just because the robot is turning, even if the robot isn‚Äôt moving forward! This variable cancels that out. | . | delta ($\\Delta$) | A fancy math symbol for ‚ÄúThe Change.‚Äù ($New Value - Old Value$) | . | radians | A different way to measure angles. Instead of 0-360, it uses 0 to 6.28 ($2\\pi$). Computers prefer this for trigonometry. | . ",
    "url": "/chapter-05-Odometry.html#3-parameters-explained",
    
    "relUrl": "/chapter-05-Odometry.html#3-parameters-explained"
  },"20": {
    "doc": "Chapter 5: Odometry",
    "title": "4. Usage Examples for Odometry",
    "content": "Example 1: The ‚ÄúSelf-Correcting‚Äù Intake . You can use your $(X, Y)$ position to make decisions automatically. C++ . // If the robot is in the middle of the field (X &gt; 70), start spinning the intake. if (x_pos &gt; 70.0) { Intake.spin(fwd, 12, volt); } . Example 2: Distance to Target . Instead of guessing how far to drive, you can use the Pythagorean Theorem ($a^2 + b^2 = c^2$) to find the exact distance to a goal. C++ . double targetX = 120.0, targetY = 120.0; double distance = hypot(targetX - x_pos, targetY - y_pos); // Drive until you are within 5 inches of the goal while(distance &gt; 5.0) { driveChassis(6, 6); distance = hypot(targetX - x_pos, targetY - y_pos); wait(10, msec); } . Example 3: Manual Calibration . If the robot bumps into a wall, you can ‚Äúreset‚Äù its position to a known value to fix any tiny errors that built up. C++ . // If the back bumper switch is pressed against the starting wall: if (Bumper.pressing()) { x_pos = 0; y_pos = 0; inertial_sensor.setRotation(0, degrees); } . ",
    "url": "/chapter-05-Odometry.html#4-usage-examples-for-odometry",
    
    "relUrl": "/chapter-05-Odometry.html#4-usage-examples-for-odometry"
  },"21": {
    "doc": "Chapter 5: Odometry",
    "title": "Chapter 5: Odometry",
    "content": " ",
    "url": "/chapter-05-Odometry.html",
    
    "relUrl": "/chapter-05-Odometry.html"
  },"22": {
    "doc": "Chapter 6: Pure Pursuit and Boomerang",
    "title": "1. What is Pure Pursuit?",
    "content": "The ‚ÄúCarrot on a Stick‚Äù Trick . Imagine you are holding a carrot on a long stick in front of a donkey. As the donkey moves toward the carrot, you move the stick. The donkey never stops; it just keeps curving to follow the carrot. | In moveToPoint, the Target Point is the carrot. | The Look-Ahead is the length of the stick. | The robot is constantly ‚Äústeering‚Äù toward that point while driving forward, which creates a smooth curve instead of a sharp, jerky turn. | . The Math (Simplified) . Every second, the robot asks itself three questions: . | ‚ÄúHow far away am I?‚Äù It uses the distance formula (math you‚Äôll learn in Algebra) to see if it needs to go full speed or start slowing down. | ‚ÄúWhere am I facing?‚Äù It looks at its Odometry (those tracking wheels on your 1/16‚Äù poly mounts) to see its current angle. | ‚ÄúHow much do I need to turn?‚Äù This is the Curvature. Instead of stopping to turn, it just tells one side of the drivetrain to spin a little faster than the other. This lets it ‚Äúarc‚Äù toward the target. | . 2. The Mathematical Steps . When you call moveToPoint(x, y), the code performs these calculations dozens of times per second: . | Distance Calculation: It uses the Pythagorean theorem to find how far it is from the target: . \\[\\text{Distance} = \\sqrt{(x_{target} - x_{robot})^2 + (y_{target} - y_{robot})^2}\\] | Target Bearing: It calculates the angle ($\\theta$) required to face the point using atan2: . \\[\\text{Target Angle} = \\operatorname{atan2}(y_{target} - y_{robot}, x_{target} - x_{robot})\\] | Error Calculation: It compares the Target Angle to the robot‚Äôs Current Heading (from Odometry). | Curvature (The Secret Sauce): Instead of stopping to turn, it calculates a ‚ÄúCurvature‚Äù value. It tells the robot: ‚ÄúTo hit that point while moving forward, the left wheels need to spin at 90% power and the right wheels at 70% power.‚Äù . | . The Two ‚ÄúCoaches‚Äù (Dual PID) . Inside the moveToPoint code, there are two ‚ÄúCoaches‚Äù shouting instructions at the same time: . | The Distance Coach (Linear PID): ‚ÄúWe‚Äôre far away, go fast!‚Äù ‚Ä¶ ‚ÄúOkay, we‚Äôre getting close, slow down‚Ä¶ slow down‚Ä¶ STOP!‚Äù . | The Steering Coach (Angular PID): ‚ÄúYou‚Äôre drifting left! Turn right!‚Äù ‚Ä¶ ‚ÄúNow you‚Äôre straight, keep it there!‚Äù . | . Because both coaches work at the same time, the robot can drive forward and turn at once. This saves a lot of time during a 15-second autonomous period. When does it stop? (The ‚ÄúClose Enough‚Äù Rule) . In the real world, a robot almost never hits a coordinate perfectly. If you tell it to go to $(10, 10)$, it might get to $(10.1, 9.9)$ and start wiggling forever trying to be perfect. To fix this, the code has Exit Conditions: . | The ‚ÄúGood Enough‚Äù Zone: If the robot is within 0.5 inches of the target, it counts as a win. | The ‚ÄúSettling‚Äù Timer: The robot has to stay in that zone for a split second to make sure it didn‚Äôt just fly past it. | The ‚ÄúI‚Äôm Stuck‚Äù Timer: If the robot hits a wall or a game piece and hasn‚Äôt moved for 2 seconds, the code ‚Äúgives up‚Äù and moves to the next command so you don‚Äôt waste your whole autonomous run. | . ",
    "url": "/chapter-06-Pure-Pursuit-and-Boomerang.html#1-what-is-pure-pursuit",
    
    "relUrl": "/chapter-06-Pure-Pursuit-and-Boomerang.html#1-what-is-pure-pursuit"
  },"23": {
    "doc": "Chapter 6: Pure Pursuit and Boomerang",
    "title": "2. What is the Boomerang Algorithm?",
    "content": "The Boomerang algorithm is an ‚Äúupgrade‚Äù to Pure Pursuit. Pure Pursuit is great for following a line, but it has one big problem: It doesn‚Äôt care what direction you are facing when you arrive. If you want to arrive at a goal facing exactly 90 degrees to score a point, Pure Pursuit might leave you facing 70 or 110 degrees. Boomerang fixes this by projecting the ‚ÄúCarrot Point‚Äù based on your desired final heading. Boomerang Line-by-Line Breakdown . Here is how the logic works inside motor-control.cpp: . C++ . // 1. Calculate the distance to the ACTUAL goal double h = hypot(x - x_pos, y - y_pos); // 2. Calculate the \"Carrot Point\" (The virtual target) // We take the final target (x, y) and \"stretch\" it out based on the desired angle (a). // dlead is the \"Lead Factor\" - it controls how far away the carrot is. double carrot_x = x - h * cos(degToRad(a)) * dlead; double carrot_y = y - h * sin(degToRad(a)) * dlead; // 3. Aim at the Carrot // atan2 finds the angle from our current (x_pos, y_pos) to the (carrot_x, carrot_y). double target_angle = radToDeg(atan2(carrot_x - x_pos, carrot_y - y_pos)); // 4. Drive Logic // Linear power (forward speed) is based on the REAL target distance (h). double move_output = movePID.update(h); // Turning power is based on the angle to the CARROT. double turn_output = turnPID.update(getAngleError(target_angle)); . What is a ‚ÄúCarrot Point‚Äù? . In your code, the Carrot Point is a virtual goal that ‚Äúdangles‚Äù in front of the robot. Think of a cartoon donkey with a carrot hanging from a stick on its head. The donkey (the robot) moves toward the carrot. Because the stick is attached to the donkey, the carrot is always moving, pulling the donkey along a path. In the boomerang function, the carrot point isn‚Äôt just the final destination $(x, y)$. It is a point calculated to be some distance away from the destination, aligned with the final angle you want to reach. üçé Why is the ‚ÄúCarrot Point‚Äù useful . Think of the Boomerang code like this: If you try to run directly at a chair and sit down, you might hit the chair or sit on the edge. But if you imagine a ‚ÄúGhost Chair‚Äù (the Carrot Point) 2 feet behind the real chair, you will naturally walk toward the ghost chair and ‚Äúland‚Äù perfectly in the real chair while facing the right way. ",
    "url": "/chapter-06-Pure-Pursuit-and-Boomerang.html#2-what-is-the-boomerang-algorithm",
    
    "relUrl": "/chapter-06-Pure-Pursuit-and-Boomerang.html#2-what-is-the-boomerang-algorithm"
  },"24": {
    "doc": "Chapter 6: Pure Pursuit and Boomerang",
    "title": "3. Examples of Boomerang &amp; Carrot Logic",
    "content": "Example 1: The ‚ÄúWide Sweep‚Äù (High Lead) . If you have a big obstacle in the middle of the field, you want a wide, circular path. You set dlead to a higher value (like 0.8). This puts the ‚Äúcarrot‚Äù far away, forcing the robot to take a wide turn. C++ . // dlead = 0.8 (Wide curve to avoid a center obstacle) boomerang(48, 48, 1, 90, 0.8, 3000, true, 12); . Example 2: The ‚ÄúTight Hook‚Äù (Low Lead) . If you are already close to a goal and just need to snap into a specific angle, you use a low dlead (like 0.2). The carrot is very close to the target, so the robot drives more directly. C++ . // dlead = 0.2 (Sharp turn to face a goal exactly) boomerang(12, 24, 1, 0, 0.2, 1500, true, 10); . Example 3: The ‚ÄúBackwards Boomerang‚Äù . If your robot has a claw on the back, you use a direction (dir) of -1. The math flips, and the robot ‚Äúbacks into‚Äù the carrot point. C++ . // dir = -1 (Reverse curve to score with a rear-mounted lift) boomerang(-24, 0, -1, 180, 0.5, 2500, true, 11); . ",
    "url": "/chapter-06-Pure-Pursuit-and-Boomerang.html#3-examples-of-boomerang--carrot-logic",
    
    "relUrl": "/chapter-06-Pure-Pursuit-and-Boomerang.html#3-examples-of-boomerang--carrot-logic"
  },"25": {
    "doc": "Chapter 6: Pure Pursuit and Boomerang",
    "title": "Summary Table",
    "content": "| Term | Simple Definition | Role in Your Code | . | Pure Pursuit | Following a point ahead of you. | The basic way your robot follows a path. | . | Carrot Point | The ‚Äúfake‚Äù target the robot aims for. | Calculated using carrot_x and carrot_y. | . | Boomerang | Curving to hit a specific final angle. | The function boomerang() that handles X, Y, and Angle. | . | dlead | How far the carrot is from the goal. | Determines if your curve is ‚ÄúWide‚Äù or ‚ÄúSharp.‚Äù | . | h (Hypotenuse) | Straight line distance to the goal. | Used to slow down the robot as it gets close. | . ",
    "url": "/chapter-06-Pure-Pursuit-and-Boomerang.html#summary-table",
    
    "relUrl": "/chapter-06-Pure-Pursuit-and-Boomerang.html#summary-table"
  },"26": {
    "doc": "Chapter 6: Pure Pursuit and Boomerang",
    "title": "Chapter 6: Pure Pursuit and Boomerang",
    "content": " ",
    "url": "/chapter-06-Pure-Pursuit-and-Boomerang.html",
    
    "relUrl": "/chapter-06-Pure-Pursuit-and-Boomerang.html"
  },"27": {
    "doc": "Chapter 7: Pure Pursuit",
    "title": "Chapter 7: Pure Pursuit",
    "content": "üõ†Ô∏è Detailed Breakdown: How it Works . The moveToPoint(x, y, timeout, maxSpeed) function runs through a fast internal loop (usually every 10‚Äì20 milliseconds) following these steps: . | Coordinate Math: It looks at your current $(x, y)$ from the tracking wheels and calculates the distance to the target $(x_{goal}, y_{goal})$. | Angle Calculation: It determines the Target Heading. If the robot is at $(0,0)$ and the target is at $(10,10)$, the math says ‚ÄúTurn to 45 degrees.‚Äù . | The ‚ÄúSwing‚Äù (Curvature): This is the ‚ÄúPure Pursuit‚Äù part. Instead of stopping to turn, the code calculates how much faster the left wheels need to spin compared to the right wheels to create an arc. | PID Speed Control: * Linear PID: As the robot gets closer to the point, it automatically lowers the motor voltage so it doesn‚Äôt ‚ÄúBang‚Äù into the target. | Angular PID: It constantly makes tiny steering corrections to stay on the arc. | . | Exit Condition: The function ends when the robot is within a certain distance (e.g., 0.5 inches) or if the timeout clock runs out. | . üìù 3 Examples of moveToPoint in Action . Here are three ways you would actually use this in your autonomous code. (Note: The specific syntax for timeout and maxSpeed might vary slightly depending on your version of the template). Example 1: The Simple ‚ÄúSprint‚Äù . Use this for the very first move of a match to grab a goal or a game piece quickly. C++ . // Move to 24 inches forward and 0 inches side-to-side // Timeout after 2000ms, max speed 100% chassis.moveToPoint(0, 24, 2000, 100); . | Result: The robot drives straight at full speed and slows down right as it hits the 24-inch mark. | . Example 2: The ‚ÄúSmooth Curve‚Äù (Sequential Points) . This is where the algorithm shines. By calling two points in a row, the robot doesn‚Äôt stop between them; it creates a fluid motion. C++ . chassis.moveToPoint(12, 12, 1500, 80); // Move to the first corner chassis.moveToPoint(0, 24, 1500, 80); // Curve toward the second point . | Result: Because of the curvature logic, the robot will ‚Äúround off‚Äù the first point and transition smoothly into the second move, saving precious seconds in autonomous. | . Example 3: Reaching Backward (Reverse Movement) . Sometimes your intake is on the front, but you need to move to a goal with your back ‚ÄúMOGO‚Äù hitch. C++ . // Many templates use a boolean (true/false) to indicate driving in reverse chassis.moveToPoint(0, -24, 2000, 60, true); . | Result: The robot uses its rear-facing logic to back up toward the coordinate $(-24, 0)$ at a slower, more controlled speed (60%) to ensure it doesn‚Äôt miss the goal. | . ",
    "url": "/chapter-07-Pure-Pursuit.html",
    
    "relUrl": "/chapter-07-Pure-Pursuit.html"
  },"28": {
    "doc": "Chapter 8: Boomerang",
    "title": "Boomerang Algorithm Breakdown (motor-control.cpp)",
    "content": "The Boomerang algorithm is a ‚ÄúPure Pursuit‚Äù variation. Instead of driving straight to a point, it aims for a ‚Äúcarrot point‚Äù slightly in front of the target to create a smooth curve. Parameter Definitions . | Parameter | Description | . | x, y | The global coordinates of the target on the field. | . | dir | Direction of travel: 1 for forward, -1 for backward. | . | a | The final heading (angle) the robot should face when it arrives. | . | dlead | The ‚Äúlead‚Äù factor (usually 0.0 to 1.0). Determines how wide the curve is. | . | exit | If true, the robot stops at the end. If false, it carries momentum into the next command. | . Code Logic Breakdown . C++ . void boomerang(double x, double y, int dir, double a, double dlead, ...) { is_turning = true; PID movePID(move_kp, move_ki, move_kd); // Control forward/backward speed PID turnPID(turn_kp, turn_ki, turn_kd); // Control steering while(!movePID.targetArrived()) { // 1. Calculate distance from current (x_pos, y_pos) to target (x, y) double h = hypot(x - x_pos, y - y_pos); // 2. The Carrot Point Logic: // This creates a target angle based on the final angle (a) and the current distance (h). // As h gets smaller, the robot's target angle shifts more toward the final desired angle. double carrot_x = x - h * cos(degToRad(a)) * dlead; double carrot_y = y - h * sin(degToRad(a)) * dlead; // 3. Calculate the angle needed to face that carrot point. double target_angle = radToDeg(atan2(carrot_x - x_pos, carrot_y - y_pos)); // 4. Calculate PID Outputs // Linear power is based on distance to the ACTUAL target. double move_output = movePID.update(h); // Rotational power is based on the angle to the CARROT point. double turn_output = turnPID.update(getAngleError(target_angle)); // 5. Motor Mixing // Combines forward speed and turning speed into left/right voltages. double left_output = move_output + turn_output; double right_output = move_output - turn_output; // 6. Safety Scaling: Ensure we don't exceed max voltage while maintaining the curve ratio. scaleToMax(left_output, right_output, max_output); // 7. Slew Rate: Prevent \"jerking\" by limiting how fast voltage can change per loop. if(left_output - prev_left_output &gt; max_slew_fwd) { left_output = prev_left_output + max_slew_fwd; } driveChassis(left_output, right_output); prev_left_output = left_output; wait(10, msec); } } . ",
    "url": "/chapter-08-Boomerang.html#boomerang-algorithm-breakdown-motor-controlcpp",
    
    "relUrl": "/chapter-08-Boomerang.html#boomerang-algorithm-breakdown-motor-controlcpp"
  },"29": {
    "doc": "Chapter 8: Boomerang",
    "title": "Usage Examples with Code Snippets",
    "content": "Scenario A: Executing a Boomerang Curve . Moving to a goal while curving around an obstacle to face a specific direction. C++ . // Target: X=36, Y=36 (middle of the field) // Final Angle: 180 degrees (facing the back wall) // Lead: 0.6 (medium curve) // Max Speed: 10 volts boomerang(36.0, 36.0, 1, 180.0, 0.6, 3000, true, 10.0); . Scenario B: Multi-Point Pathing (Chaining) . Using the exit parameter to move through multiple points without stopping. C++ . // 1. Curve toward the first point but don't stop (exit = false) boomerang(24, 24, 1, 45, 0.5, 2000, false, 12.0); // 2. Immediately transition into a second curve to the final goal boomerang(48, 0, 1, 0, 0.4, 2000, true, 12.0); . Scenario C: Fine-Tuning the ‚ÄúCarrot‚Äù . Comparing different dlead values. C++ . // dlead = 0.1: Very sharp, direct movement. Almost a straight line then a turn. boomerang(24, 24, 1, 90, 0.1, 3000, true, 12); // dlead = 0.9: Very wide, sweeping arc. Useful for avoiding a big center obstacle. boomerang(24, 24, 1, 90, 0.9, 3000, true, 12); . ",
    "url": "/chapter-08-Boomerang.html#usage-examples-with-code-snippets",
    
    "relUrl": "/chapter-08-Boomerang.html#usage-examples-with-code-snippets"
  },"30": {
    "doc": "Chapter 8: Boomerang",
    "title": "Chapter 8: Boomerang",
    "content": " ",
    "url": "/chapter-08-Boomerang.html",
    
    "relUrl": "/chapter-08-Boomerang.html"
  },"31": {
    "doc": "Chapter 9: Autonomous Troubleshooting Guide",
    "title": "1. PID Issues (Stuttering &amp; Overshooting)",
    "content": "| Symptom | Probable Cause | Fix | . | Violent Shaking | $K_p$ is too high. | Lower your $K_p$ value by 20% increments. | . | Robot stops early | Friction is higher than motor power. | Increase $K_i$ slightly or lower the derivative_tolerance. | . | Never stops moving | $K_i$ is ‚Äúwinding up‚Äù or tolerances are too tight. | Lower $K_i$ or increase small_error_tolerance. | . | Overshoots Target | $K_d$ is too low (not enough braking). | Increase $K_d$ to add more damping/braking force. | . How to ‚ÄúTune‚Äù from scratch: . | Set $K_i$ and $K_d$ to 0. | Increase $K_p$ until the robot reaches the target but oscillates (bounces) slightly. | Increase $K_d$ until the bouncing stops. | If the robot stops 1 inch short of the target, add a very small $K_i$ (start at 0.001). | . ",
    "url": "/chapter-09-Autonomous-Troubleshooting-Guide.html#1-pid-issues-stuttering--overshooting",
    
    "relUrl": "/chapter-09-Autonomous-Troubleshooting-Guide.html#1-pid-issues-stuttering--overshooting"
  },"32": {
    "doc": "Chapter 9: Autonomous Troubleshooting Guide",
    "title": "2. Odometry Issues (The ‚ÄúDrift‚Äù)",
    "content": "If your robot thinks it is at $(10, 10)$ but it is actually at $(15, 8)$, you have an Odometry drift problem. | Symptom | Probable Cause | Fix | . | Inaccurate X/Y | Wrong wheel_diameter in code. | Measure your tracking wheels with a caliper. Standard is usually 2.75‚Äù or 2‚Äù. | . | Turning breaks X/Y | Wrong dist_from_center value. | Measure the distance from the center of the robot to your tracking wheels exactly. | . | Position ‚Äújumps‚Äù | Encoder wires are loose or static. | Ensure cables are secure and spray tiles with anti-static spray. | . | Angle is wrong | Inertial sensor not calibrated. | Ensure Inertial.calibrate() runs while the robot is completely still. | . Pro Tip: If your robot is consistently off by a certain percentage (e.g., it always thinks 24 inches is 22 inches), multiply your wheel diameter by a ‚Äúscaling factor‚Äù (like $1.05$) to calibrate it. ",
    "url": "/chapter-09-Autonomous-Troubleshooting-Guide.html#2-odometry-issues-the-drift",
    
    "relUrl": "/chapter-09-Autonomous-Troubleshooting-Guide.html#2-odometry-issues-the-drift"
  },"33": {
    "doc": "Chapter 9: Autonomous Troubleshooting Guide",
    "title": "3. Boomerang &amp; Pathing Issues",
    "content": "Problem: The robot circles the target forever. | Why: Your small_error_tolerance is too small, or your robot is too fast to ‚Äúcatch‚Äù the point. | Fix: Increase the tolerance or lower the max_output (voltage). | . Problem: The curve is too wide or too sharp. | Why: The dlead parameter is incorrectly set. | Fix: * Too Wide: Lower dlead (closer to 0.1). | Too Sharp: Raise dlead (closer to 0.7). | . | . Problem: The robot arrives but faces the wrong way. | Why: Your a (angle) parameter is in the wrong format (Degrees vs Radians) or the dir (direction) is wrong. | Fix: Ensure you use Degrees (0-360) and check that dir is 1 for forward and -1 for reverse. | . ",
    "url": "/chapter-09-Autonomous-Troubleshooting-Guide.html#3-boomerang--pathing-issues",
    
    "relUrl": "/chapter-09-Autonomous-Troubleshooting-Guide.html#3-boomerang--pathing-issues"
  },"34": {
    "doc": "Chapter 9: Autonomous Troubleshooting Guide",
    "title": "4. Hardware Safety Checklist",
    "content": "Before you spend hours changing code, check these three physical things: . | Wheel Friction: Pick the robot up and spin the tracking wheels. They should spin freely for several seconds. If they stop instantly, they are too tight. | Motor Temperature: If motors are hot to the touch, the PID is fighting itself. Lower your $K_p$. | Center of Mass: If your robot is ‚Äúback-heavy,‚Äù the front tracking wheels might lift off the ground during acceleration, ruining your Odometry. | . ",
    "url": "/chapter-09-Autonomous-Troubleshooting-Guide.html#4-hardware-safety-checklist",
    
    "relUrl": "/chapter-09-Autonomous-Troubleshooting-Guide.html#4-hardware-safety-checklist"
  },"35": {
    "doc": "Chapter 9: Autonomous Troubleshooting Guide",
    "title": "Chapter 9: Autonomous Troubleshooting Guide",
    "content": " ",
    "url": "/chapter-09-Autonomous-Troubleshooting-Guide.html",
    
    "relUrl": "/chapter-09-Autonomous-Troubleshooting-Guide.html"
  },"36": {
    "doc": "Chapter 10: Documentation of Programming",
    "title": "Documentation of PID",
    "content": "To effectively explain PID in your engineering notebook, you should use diagrams that visualize how the robot ‚Äúthinks‚Äù and how the math translates into movement. Here are the four most useful types of images for your documentation: . 1. The PID Control Loop Diagram . This is the standard ‚Äúmap‚Äù of a PID system. It shows how the Sensor (Inertial or Encoder) sends data back to the Controller to calculate the Error, which then adjusts the Motor Output.1 . 2. The PID Response Curve (The ‚ÄúTuning Graph‚Äù) . This graph is essential for your engineering notebook. It shows what happens when your constants are set differently. | Underdamped: The line bounces over the target (too much P). | Overdamped: The line takes a long time to reach the target (too much D or too little P). | Critically Damped: The ‚ÄúGolden‚Äù line that reaches the target perfectly and stays there. | . 3. Proportional Gain vs. Error . This visualizes the ‚ÄúP‚Äù term. It shows that the motor power is a direct reflection of the distance remaining. Big distance = Big power. Small distance = Small power. 4. Component Comparison Graph . This is helpful for explaining the individual roles of P, I, and D. It usually shows three separate lines: one where the power drops as you arrive (P), one where it builds up over time (I), and one that ‚Äúfights‚Äù the speed (D). How to use these in your notebook: . | Next to your code: Place the Control Loop Diagram to show you understand the system architecture. | In your tuning tables: Place a sketch of a Response Curve to explain why you decided to increase $K_d$ (e.g., ‚ÄúOur graph looked like the Underdamped line, so we added $K_d$ to smooth the curve‚Äù). | In the Glossary: Use the Proportional vs. Error graph to define the term ‚ÄúLinear Scaling.‚Äù . | . ",
    "url": "/chapter-10-Documentation-of-Programming.html#documentation-of-pid",
    
    "relUrl": "/chapter-10-Documentation-of-Programming.html#documentation-of-pid"
  },"37": {
    "doc": "Chapter 10: Documentation of Programming",
    "title": "Chapter 10: Documentation of Programming",
    "content": "To create a professional, high-scoring engineering notebook for a competition like VEX, you need to treat it like a scientific journal. Judges look for a ‚Äúrepeatable‚Äù process‚Äîmeaning if another team found your notebook, they could build and program your exact robot just by reading it. Here is a detailed guide on how to document and tabulate your data effectively. 1. The Structure of a ‚ÄúControl‚Äù Entry . Every time you work on code (like tuning your PID or testing Odom), you should follow a standard template. This makes your notebook clean and easy for judges to navigate. | Title &amp; Date: (e.g., ‚ÄúTuning Drive PID Coefficients‚Äù) . | Goal: What are you trying to achieve? (e.g., ‚ÄúStop the robot within 0.5 inches of target with zero oscillation.‚Äù) . | The ‚ÄúWhy‚Äù: Explain the math. (This is where you use the Glossary terms like Derivative or Error). | The Setup: List your initial constants ($K_p$, $K_i$, $K_d$). | . 2. How to Tabulate Testing Data . Never just write ‚Äúit worked better.‚Äù You need hard numbers. Tables are the best way to show judges that you are using a logical, iterative process. Example: PID Tuning Table . Use a table like this to show your ‚ÄúTrial and Error‚Äù progress. | Trial # | Kp‚Äã | Ki‚Äã | Kd‚Äã | Result/Observation | Action Taken | . | 1 | 0.5 | 0 | 0 | Robot stopped 4 inches short. | Increase $K_p$ | . | 2 | 1.2 | 0 | 0 | Reached target but bounced 3 times. | Add $K_d$ to brake. | . | 3 | 1.2 | 0 | 2.5 | Smooth stop, but 0.25‚Äù short. | Add tiny $K_i$. | . | 4 | 1.2 | 0.01 | 2.5 | Success. Perfect landing. | Finalize Values. | . 3. Documenting Odometry (X/Y Accuracy) . When testing Odometry, you need to prove the robot knows its position. The ‚ÄúSquare Test‚Äù Table: Program the robot to drive in a $24‚Äù \\times 24‚Äù$ square and return to $(0,0)$. | Test Run | Target (X,Y) | Actual (X,Y) | Error (Distance) | Notes | . | Run 1 | $(0, 0)$ | $(0.5, -0.2)$ | 0.53‚Äù | Slight drift to the right. | . | Run 2 | $(0, 0)$ | $(0.1, 0.1)$ | 0.14‚Äù | Tightened tracking wheel pod. | . 4. Visual Documentation . Judges love visuals. Don‚Äôt just use text; use diagrams and screenshots. | Code Snippets: Don‚Äôt print 50 pages of code. Copy and paste the specific function you worked on (like the boomerang math) and highlight the lines you changed. | Path Diagrams: Draw the field. Show the ‚ÄúIntended Path‚Äù vs. the ‚ÄúActual Path.‚Äù . | Intended: A smooth Boomerang curve. | Actual: A jagged line because the dlead was too low. | . | Graphs: If you can, use the V5 Brain or a laptop to graph your PID error. A graph showing the error curve dropping to zero is worth a thousand words. | . 5. The ‚ÄúLogic Flow‚Äù Diagram . Before writing code, draw a Flowchart. This shows that you planned the logic before you started typing. For a Boomerang move, your flowchart might look like this: . | Start: Receive Target $(X, Y, Angle)$. | Calculate: Find distance to target ($h$). | Find Carrot: Project Carrot Point based on $h$ and $dlead$. | Loop: * Update PIDs. | Check: Is $h &lt;$ Tolerance? . | If No: Keep driving. | If Yes: Stop/Exit. | . | . 6. Best Practices for the Engineering Notebook . | Do | Don‚Äôt | . | Use Pens: If you make a mistake, cross it out with one line. Never use white-out. | Erase: Judges want to see your mistakes and how you fixed them. | . | Explain ‚ÄúFailure‚Äù: If the robot crashed, explain why. | Ignore Problems: A notebook with zero failures looks fake. | . | Sign and Date: Every page should be signed by the person who wrote it. | Leave Blank Space: If a page is half-empty, draw a diagonal line through it. | . | Reference the Math: Explicitly mention ‚ÄúWe used the hypot() function for distance.‚Äù | Be Vague: Avoid words like ‚Äúfast,‚Äù ‚Äúgood,‚Äù or ‚Äúa lot.‚Äù Use ‚Äú12 volts,‚Äù ‚Äú0.5 inches,‚Äù or ‚Äú80%.‚Äù | . Summary for the Team . An engineering notebook is a story. It‚Äôs the story of how you started with a robot that couldn‚Äôt drive straight and ended with a robot that uses Pure Pursuit and Odometry to dominate the field. Use your Glossary and your Tables to tell that story with facts! . ",
    "url": "/chapter-10-Documentation-of-Programming.html",
    
    "relUrl": "/chapter-10-Documentation-of-Programming.html"
  }
}
